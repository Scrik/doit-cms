Модуль Active Record (mod_orm)
==============================

mod_orm добавляет поддержку объекта Active Record для упрощения SQL-запросов. Не смотря на то, что это подключаемый и отчуждаемый модуль, он глубоко вшит в систему, забирает себе функцию `__autoload()` и предоставляет единственный способ работы с базой данных (кроме непосредственной работ при помощи родных функций `mysql_*`)

Особенностью является следеющее: если функция не имеет параметров, то её можно вызывать в качестве переменной, просто
опустив скобки (в большинстве случаев также доступен классический подход), например

	d()->User->all;
	d()->User->one;
	d()->User->expand_to_client;

### Объявление
Для указания того, какой таблице соответствует объект, ничего не нужно. Объявлять класс для
каждого отдельного типа объекта тоже не обязательно.

Для поиска по таблице users используется запись `d()->Users;`

Например:

	d()->User->find(2)->title;

Для поиска по любой другой таблице используется имя объекта, начинаемое с заглавной
буквы, и представляющее собой название таблицы в единственном числе по правилам
английской грамматики.

Например, `d()->Category` ищет по таблице categories, а `d()->News` ищет по таблице news

Альтернативная запись `d('User')` (Примечание: такая запись подходит для запроса любого
свойства основного объекта, например, `d('title')`).

Для дальнейшего использования можно передавать вызовы по цепочке или используя
промежуточный объект:

	print d()->User->find(2)->title;

равнозначно

	$user= d()->User;
	$user=$user->find(2);
	print $user->title;

либо равнозначно

	$user2= d()->User;
	$user2->find(2);
	print $user2->login;
	
Также разрешён альтернативный подход

	$user2= new User();
	$user2->find(2);
	print $user2->login;

Также разрешается объявлять класс самому, наследуя его от класса ar

В этом случае имеется возможность использовать свои методы класса и переопределять
существующие.

### `find()`

Осуществляет поиск по id

	d()->User->find(34);
	
Непосредственно запрос выполнится перед получением данных (ленивый запрос).

Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### `find_by_<field>`

Ищет по определённому полю и автоматически экранирует запрос для предотвращения SQL-
инъекций. Например:

	d()->User->find_by_login('ainu') 	// ищет по полю login
	d()->User->find_by_username('ainu') // ищет по полю username
	
Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### `where()`

where задаёт условия для будущего запроса и автоматически экранирует запрос для
предотвращения SQL-инъекций. Отменяет действие выполненных ранее функций `find()`,
`find_by_*()`, `where()`

Например:

	d('User')->where('login = ? and password=?', $username, md5($password));
	d('User')->where('login LIKE ?', '%строка%');
	
### `all`
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов ActiveRecord).

	$goods = d()->Good->find_by_color('red')->all;
	print $goods[0]->title;

	
### `tree`
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов ActiveRecord). При этом, даже если была запрошен вся таблица, в массиве будут только данные из корня.

Допустим, текущая таблица comments. Каждый комментарий имеет поле `page_id` (или, допустим, url страницы) и `comment_id`, указывающий на родительский комментарий.

Тогда получив все комментарии к одной странице, где `page_id=номер страницы`, и запросив tree, мы получим только корневые элементы - комментарии. Запросив свойство tree каждого из этих комментариев, мы получим дочерние комментарии. При этом делается один запрос, и данные сортируются и прозрачно помещаются в многомерный массив.

Используется для простой выдачи многомерных деревьев (комментарии, главные меню и так далее).

По сути, функция tree всего лишь сортирует данные в массиве, ориентируясь на поле element_id, где текущая таблица - elements, и возвращает результат. Таким образом  одним запросом получаются все данные дерева, программно сортируются, и выводятся в виде заранее подготовленного массива с данными. Глубина безлимитна.

	//Дерево комментариев
	d()->comments = d()->Comment->find_by_page_id(12)->tree;
	//Комментарий четвёртого уровня вложенности
    print  d()->Text->tree[0]->tree[0]->tree[0]->tree[0]->title; 
	
### one
Выполняет SQL-запрос (если не выполнен) и возвращает один объект (первый) в виде
объекта. Почти всегда можно опускать (при запросе свойства запрос выполнится автоматически).

	$maika = d()->Good->find(12)->one;
	
### `is_empty`
Немедленно выполняет SQL - запрос (до попытки получения первого свойства), и возвращает
true, если получено 0 элементов.

### `expand` и `expand_to`
Функции копируют данные из ActiveRecord объекта в глобальную область объектов для
использования в шаблонах

	d('Text')->find_by_url(url(1))->expand_to_page;
	
После этого в шаблоне можно указывать `{page.title}`

	d()->Client->find_by_name('Керхер')->expand_to_client;
	
После этого в шаблоне можно указывать `{client.title}`

	d()->Client->find(374)->expand;
	
После этого в шаблоне можно указывать `{title}`

Примечание: от функции expand можно отказаться классическим методом:

	d()->page = d('Text')->find_by_url(url(1));
	
После этого в шаблоне можно указывать `{page.title}`

Возвращает `false`, если подходящих строк не было найдено.

### `new`, `save` и `delete`
`save` и `delete` завершают предыдущие операции, используются для установки флага
дальнейшего создания строки в базе данных, сохранения данных и удаления строки.

`delete` - удаляет последний найденный через find элемент, если элементы искались через
where, то удаляется первый. Фактически, при `$var->delete;` удаляется элемент с id, равным `$var->id`.

Если такой строки нет, ничего не произойдёт.

`save` - сохраняет изменения. Функция new не совершает никаких действий с базой данных,
только указывает на необходимость создания новой строки в базе данных. Если до save было
сделано $var->new, то при сохранении создастся новая строка, иначе изменится последняя
найденная через find или where строка. Если при попытке сохранения для изменений после
поиска строк было несколько, то изменится первая. Фактически, при $var->save; меняется
элемент с `id` = $var->id. Если такой строки нет, ничего не произойдёт.

Для задания поля необходимо присвоить значение соответствующей переменной. Например,

	$var->title='Заголовок';
	
Внимание: регистр букв важен.
Итак, основные действия:

**Создание:**

	d()->client = d()->Client->new;
	d()->client->title='ainu';
	d()->client->text='Суперклиент';
	d()->client->save();
	
**Редактирование:**

	d()->client = d()->Client->find(12);
	d()->client->title = "Новый заголовок";
	d()->client->save();
	
**Удаление:**

	d()->client = d()->Client->find(12);
	d()->client->delete();
	
Если (например, при редактировании или создании) не было присвоено значение полю, то в
самом запросе с этим полем действий не произойдёт. На данном этапе абстракций нет,
поэтому для указания, например, автора статьи, необходимо указывать id:

	$article = d()->Article->new;
	$article->author_id = 21;
	$article->save;
	
При указании `->new` можно действовать так:

	d()->client = d()->Client;
	d()->client->new;
	d()->client->title='Имя';
	d()->client->save;
	
или так:

	d()->client = d()->Client;
	d()->client->new->title='Имя';
	d()->client->save;
	
или вообще без промежуточного объекта:

	d()->Client->find(7)->delete();
	
### Связи

Все три вида связей (one-to-many, many-to-one, many-to-many) объявляются автоматически.

TODO:

	$user->posts
	$post->user

