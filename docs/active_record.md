Модуль Active Record (mod_orm)
==============================

mod_orm добавляет поддержку объекта Active Record для упрощения SQL-запросов. Не смотря на то, что это подключаемый и отчуждаемый модуль, он глубоко вшит в систему, забирает себе функцию `__autoload()` и предоставляет единственный способ работы с базой данных (кроме непосредственной работы при помощи родных функций `mysql_*`). Поэтому он расположен в директории cms и загружается раньше пользовательских модулей.

Особенностью использования модуля является следующее: если функция (метод) не имеет параметров, то её можно вызывать в качестве переменной, просто
опустив скобки (в большинстве случаев также доступен классический подход), например:

	d()->User->all;
	d()->User->one;
	d()->User->expand_to_client;

Объявление
----------

Для указания того, какой таблице соответствует объект, ничего не нужно. Объявлять класс для
каждого отдельного типа объекта тоже не обязательно, при запросе переменной, начинающейся с заглавной буквы, вернётся
новый экземпляр соответствующего класса, готовый к использованию.

Для поиска по таблице users используется запись `d()->User;`

Например:

	d()->User->find(2)->title;

Для поиска по любой другой таблице используется имя объекта, начинаемое с заглавной
буквы, и представляющее собой название таблицы в единственном числе по правилам
английской грамматики.

Например, `d()->Category` ищет по таблице categories, а `d()->News` ищет по таблице news

Альтернативная запись: `d('User')` (Примечание: такая запись подходит для запроса любого
свойства основного объекта (переменной), например, `d('title')` или `d('article')`).

Для дальнейшего использования можно передавать вызовы по цепочке или используя
промежуточный объект:

	print d()->User->find(2)->title;

равнозначно

	$user= d()->User;
	$user=$user->find(2);
	print $user->title;

либо равнозначно

	$user2= d()->User;
	$user2->find(2);
	print $user2->login;
	
Также разрешён альтернативный подход

	$user2= new User();
	$user2->find(2);
	print $user2->login;

Также разрешается объявлять класс самому, наследуя его от класса ar. При этом имя класса должно представлять из себя имя таблицы в единственном числе и начинаться с большой буквы.

В этом случае имеется возможность использовать свои методы класса и переопределять
существующие.

Методы
------

### find()

Осуществляет поиск по id

	d()->User->find(34);
	
Непосредственно запрос выполнится перед получением данных (ленивый запрос).

Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### find\_by()


Ищет по определённому полю и автоматически экранирует запрос для предотвращения SQL-
инъекций. Принимает два параметра: первый - поле, второй - значение.

Например:

	d()->User->find_by('login', 'ainu') 	// ищет по полю login
	d()->User->find_by('username', 'ainu') // ищет по полю username
	
Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### find\_by\_&lt;field&gt;

Ищет по определённому полю и автоматически экранирует запрос для предотвращения SQL-
инъекций. Например:

	d()->User->find_by_login('ainu') 	// ищет по полю login
	d()->User->find_by_username('ainu') // ищет по полю username
	
Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### where()

where задаёт условия для будущего запроса и автоматически экранирует запрос для
предотвращения SQL-инъекций. Отменяет действие выполненных ранее функций `find()`,
`find_by_*()`, `where()`

Например:

	d('User')->where('login = ? and password=?', $username, md5($password));
	d('User')->where('login LIKE ?', '%строка%');
	
### all
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов Active Record).

	$goods = d()->Good->find_by_color('red')->all;
	print $goods[0]->title;

При этом каждой строчке в базе данных соответствует один объект. Каждый из этих объектов независим, например, он может независимо выполнять метод `save` после изменения его свойств.
	
### tree
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов Active Record). При этом, даже если была запрошена вся таблица, в массиве будут только данные из корня.

Допустим, текущая таблица comments. Каждый комментарий имеет поле `page_id` (или, допустим, url страницы) и `comment_id`, указывающий на родительский комментарий.

Тогда, получив все комментарии к одной странице, где `page_id=номер страницы`, и запросив tree, мы получим только корневые элементы - комментарии. Запросив свойство tree каждого из этих комментариев, мы получим дочерние комментарии. При этом делается один запрос, и данные сортируются и прозрачно помещаются в многомерный массив.

Используется для простой выдачи многомерных деревьев (комментарии, главные меню и так далее).

По сути, функция tree всего лишь сортирует полученные данные в массиве, ориентируясь на поле element_id, где текущая таблица - elements, и возвращает результат. Таким образом  одним запросом получаются все данные дерева, программно сортируются, и выводятся в виде заранее подготовленного массива с данными. Глубина вложенности может быть любой.

	//Дерево комментариев
	d()->comments = d()->Comment->find_by_page_id(12)->tree;
	//Заголовок текстовой страницы четвёртого уровня вложенности
    print  d()->Text->tree[0]->tree[0]->tree[0]->tree[0]->title; 
	
### one
Выполняет SQL-запрос (если не выполнен) и возвращает один объект (первый) в виде
объекта. Почти всегда можно опускать (при запросе свойства запрос выполнится автоматически).

	$maika = d()->Good->find(12)->one;
	
### is\_empty
Немедленно выполняет SQL - запрос (до попытки получения первого свойства), и возвращает
true, если получено 0 элементов.

### expand и expand\_to
Функции копируют данные из Active Record объекта в глобальную область объектов для
использования в шаблонах

	d('Text')->find_by_url(url(1))->expand_to_page;
	
После этого в шаблоне можно указывать `{page.title}`

	d()->Client->find_by_name('Керхер')->expand_to_client;
	
После этого в шаблоне можно указывать `{client.title}`

	d()->Client->find(374)->expand;
	
После этого в шаблоне можно указывать `{title}`

Примечание: от функции expand_to можно отказаться классическим методом:

	d()->page = d('Text')->find_by_url(url(1));
	
После этого в шаблоне можно указывать `{page.title}`

Возвращает `false`, если подходящих строк не было найдено.

### new, save и delete
`save` и `delete` завершают предыдущие операции, используются для установки флага
дальнейшего создания строки в базе данных, сохранения данных и удаления строки. Эти методы нужны для изменения состояния базы данных (CrUD);

`delete` - удаляет последний найденный через find элемент, если элементы искались через
where, то удаляется первый. Фактически, при `$var->delete;` удаляется элемент с id, равным `$var->id`.

Если такой строки нет, ничего не произойдёт.

`save` - сохраняет изменения. Функция new не совершает никаких действий с базой данных,
только указывает на необходимость создания новой строки в базе данных. Если до save было
сделано $var->new, то при сохранении создастся новая строка, иначе изменится последняя
найденная через find или where строка. Если при попытке сохранения для изменений после
поиска строк было несколько, то изменится первая. Фактически, при $var->save; меняется
элемент с `id` = $var->id. Если такой строки нет, ничего не произойдёт.

Для задания поля необходимо присвоить значение соответствующей переменной. Например,

	$var->title='Заголовок';
	
Внимание: регистр букв важен.
Итак, основные действия:

**Создание:**

	d()->client = d()->Client->new;
	d()->client->title='ainu';
	d()->client->text='Суперклиент';
	d()->client->save();
	
**Редактирование:**

	d()->client = d()->Client->find(12);
	d()->client->title = "Новый заголовок";
	d()->client->save();
	
**Удаление:**

	d()->client = d()->Client->find(12);
	d()->client->delete();
	
Если (например, при редактировании или создании) не было присвоено значение полю, то в
самом запросе с этим полем действий не произойдёт, т.е. изменения происходят только с теми полями, которые заданы явно.

На данном этапе абстракций нет,
поэтому для указания, например, автора статьи, необходимо указывать числовое id, вместо классического присваивания объекта как значение:

	$article = d()->Article->new;
	$article->author_id = 21;
	$article->save;
	
При указании `->new` можно действовать так:

	d()->client = d()->Client;
	d()->client->new;
	d()->client->title='Имя';
	d()->client->save;
	
или так:

	d()->client = d()->Client;
	d()->client->new->title='Имя';
	d()->client->save;
	
В случае с методом `delete` можно вообще обойтись без промежуточного объекта:

	d()->Client->find(7)->delete;
	
Данные функции являются низкоуровневыми, программисту надо следить, что он удаляет. Например, попытка удаления несуществующего объекта, может вернуть ошибку изза отсуствия поля `$var->id`.

### Быстрый доступ

Если запрашивается свойство, заведомо не являющееся столбцом таблицы и именем таблицы, то проводится попытка найти соотвествующую строку по полю url (возможно, в дальнейшем - name):

	//SELECT * from texts where url='about'
	d()->Text->about->title;
	d()->Option->email_options->send_to;
	d()->User->admin->password;
	
	
### Связи

Все три вида связей (one-to-many, many-to-one, many-to-many) объявляются автоматически.

TODO:

	$user->posts
	$post->user

