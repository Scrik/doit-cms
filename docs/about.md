О системе DoIt CMS
==================

Общие принципы
--------------

### Принцип упрощения работы приложения

Основной принцип, используемый в системе, это принцип сохранения простоты работы.

Человек, работающий с системой, должен понимать, как именно она функционирует, а для этого необходима простота и универсальность.

Если существуют две различные сущности, например фильтры в шаблонизаторе (`{page.title|uppercase}`) и функции-помощники (`{{input_tag 'title'}}`), то они должны работать схожим образом, объявляться одинаково и использовать одинаковые возможности. Таким образом, человек, привыкший к работе с фильтрами, не будет иметь проблем с помощниками. Создавать для этого два различных класса и разбираться в работе каждого из противоречит этому принципу. Поэтому в системе нет папки classes, в которой расположены некие файлы Helpers.class.php и Filters.class.php.

При разработке сделана попытка объединить все возможные сущности в несколько общих. Это привело к тому, что в шаблонизаторе используется крайне малое количество тегов, а именно три: вызов функции, вывод переменной, цикл foreach. И в случае встречи с неким тегом `{{edit}}` пользователь не будет вспоминать значение этого тега, зная, что это вызов функции `edit()`. Поэтому эту функцию можно использовать как фильтр, как помощник, как вставляемую область, как шаблон страницы, как виджет, как контроллер страницы по определённому url, как правило валидатора и так далее.

Также при разработке приветствуется избавление как от логики представления, так и от сложной логики контроллера. В простых случаях можно вообще обойтись от использования конструкции if, например, при создании формы обратной связи или создании приложения для создания и редактирования объектов пользователем при помощи форм, включая некоторые валидации.

### MVC
Используются основные принципы MVC (разделение логики, данных, и функций, их
соединяющих). Реализация отличается от классического подхода.

**Модель** – это класс, который необязательно объявлять, но его экземпляры можно
использовать. Он позволяет обращаться к базе данных как к объектам.

**Контроллер** – это множество функций, переопределяемых при помощи правил роутера. Также
это помощники (helpers , фрагменты разметки, содержащих код), обработчики для форм
(`action('client#update')`), альтернативные валидаторы, функции для отправки электронной
почты и т.д.

**Вид** – это множество функций, объявляемых автоматически на основе файлов с разметкой,
переопределяемых при помощи правил роутера. Может содержать PHP-код, например, для
сложных проверок. Каждая такая функция возвращает готовый HTML-код. Например `print d()->about();`
выведет шаблон about.html.

Также есть несколько дополнительных сущностей:

**Опции** – .ini файлы, которые инициализируют переменные (свойства) основного объекта.
Они же определяют правила роутера, списки полей для системы администрирования, опции
сайта в целом, логин и пароль администратора, правила для валидации форм. При помощи
опций можно переопределить любую функцию или шаблон, или заставить выполниться
дополнительную функцию или дополнительный шаблон, объявить переменную или массив.

**Обработчики форм** – часть контроллера, функции принимают, проверяют и обрабатывают POST
запросы. При этом они остаются обычными функциями и могут быть использованы, например, в качестве helper-ов (если в неком извращённом проекте необходимо отправлять письмо по электронной почте прямо из шаблона страницы при каждом посещении).

**Помощники (Helpers)** – функции, результат работы которых используется для генерации HTML
кода (формы, поля редактирования, ссылки, метатеги и так далее). Часть контроллера, в
большинстве своём независимые и не привязаны к какому-то определённому контроллеру. При этом они остаются обычными функциями.

### Отличия от большинства MVC фреймворков
В отличие от большинства MVC фреймворков, данный фреймворк не следует принципу «ООП
ради ООП», не является строго ООП-фреймворком, старается не плодить различные сущности,
а объединять похожие сущности едиными правилами для упрощения схемы работы и
понимания, ставит скорость разработки, поддержки, лаконичность кода, единые принципы и
гибкость выше, чем соблюдение общепринятых принципов MVC.

В отличие от большинства MVC фреймворков, модель не содержит общего кода (например,
отправка электронной почты), и вся логика содержится в контроллере (антипаттерн fat stupid ugly controllers).
Похожий подход используется в CodeIgniter. Более того, во многих проектах объявление модели может вовсе
отсутствовать.

В отличие от большинства MVC фреймворков, в некоторых случаях допустимо обращаться к
Модели из Вида, минуя контроллер, если это упростит код, его написание или поддержку.
Например:

	<ul>
		<foreach User->all as user>
			<li>{user.login}</li>
		</foreach>
	</ul>
	

Здесь выводятся все записи из таблицы users. Примечание: данный пример усложняет в
дальнейшем работу с кодом (например, добавление фильтраций или сортировки,
переопределение и т.д.). Поэтому всё-таки лучше выводить подобный код в контроллер.

В отличие от большинства MVC фреймворков, контроллер отдельной сущности может быть как
функцией, так и классом с набором методов, так и смесью двух подходов. Более того,
возможна разработка приложения без единого дополнительного класса (как контроллера, так
и модели или иных сущностей) без потери каких-либо возможностей.

В отличие от большинства MVC фреймворков, допустимо использование методов контроллера
напрямую в Виде (при помощи спец. тега, например, некая функция, получающая количество `{{users#get_count_of_all}}`),
и вызов шаблонов Вида из Контроллера для дальнейшей обработки (например, замене спец. символов).

В отличие от большинства MVC фреймворков, валидацию проводит не модель, а контроллер. 
Так как модель в контексте данной системы это прослойка для работы с базой данных, то она
не может взять на себя валидацию таких сущностей, как формы обратной связи, формы
фильтрации вывода или формы поиска данных, формы авторизации и выхода из системы,
формы калькуляторов и формы смены опций, т.к. все эти примеры не воздействуют на базу
данных, однако необходимы в реальных приложениях. Если бы валидацию проводила модель
при попытке сохранить данные (например, при редактировании статьи), а валидацию
правильной сортировки и формы отправки сообщения —контроллер, то существовали бы две
различные реализации валидатора, что противоречит принципу упрощения схемы работы
приложения.

В отличие от большинства MVC фреймворков, модель не хранит состояние приложения между
запросами в классическом понимании — модель не отвечает за хранение сессий и cookies.
Однако модель хранит состояние приложения в базе данных.

В отличие от большинства MVC фреймворков, реализация модели близка к классическим CMS,
и использует только MySQL базу данных и не имеет абстракций для работы с другими СУБД
или иными источниками данных.

В отличие от большинства MVC фреймворков, роутер способен влиять на Вид, а также
переопределять дополнительные функции-помощники (например, {{form}} или {{input}})

В отличие от большинства MVC фреймворков, каждый URL не имеет привязанного роутером
контроллера. На одной странице может существовать несколько сущностей, гибко
контролируемым независимо по правилам URL и разными контроллерами. Т.н. классические
«виджеты» (например, форма отправки почтового сообщения или форма авторизации)
работают по тем же принципам, что и основной контент, вызываются одинаково, также могут
быть переопределены по правилам роутера и представляют собой одно и то же, в
соответствии с принципом упрощения схемы работы приложения. Тоже самое касается
фрагментов HTML-вёрстки (например, {{footer}}).

В отличие от большинства MVC фреймворков, layout (разметка всей страницы) и view
(разметка контента страницы) — одна и та же сущность, в соответствии с принципом
упрощения схемы работы приложения. Более того, даже обычные функции — это та же самая
сущность, что и вышеуказанные, и могут вызываться напрямую из вида либо вообще отвечать
за общий layout.

Например, если существует функция 

	function summa() 
	{
		return 2+2;
	}
	
то следующее правило в роутере: 

	/mypage main summa

заставит по адресу http://сайт/mypage вывести число 4 вместо HTML кода всей разметки.

Переменные и функции
--------------------
Две основные сущности это переменные и функции (а также методы классов-контроллеров).

### Переменные
Переменная - свойство основного объекта. Используется для хранения глобальных объектов, свойств, выводятся в представлении.

Например:

	d()->title = "Заголовок";
	d()->text = "Полный текст";

Для того, чтобы вывести переменные, используется простая конструкция:
	
	print d()->title;
	print d()->text;
	
Так как переменные являются свойствами некоего глобального объекта системы, они глобальны, их можно объявлять в одном месте и использовать в другом.

Например, их можно вывести в представлении:

	<h1>{title}</h1>
	<p>{text}</p>

Запись `{var_name}` в представлении преобразуется в следующий php код:
	
	<?php print d()->var_name; ?>
	
Альтернативно можно использовать следующую конструкцию (как правило, бессмысленную):
	
	print d('title');	

В такую переменную можно записать экземпляр объекта, например, указав в контроллере следующий код:

	d()->user = d()->User->find(1);

После этого разрешено использовать следующую запись:

	print d()->user->title;
	
Что в шаблонизаторе будет иметь следующий аналог:

	Имя пользователя: <strong>{user.title}</strong>
	
Кроме объектов, в переменных можно хранить массивы:

	d()->user=array('title'=>'vasya');
	print d()->user['title'];
	
Что в шаблонизаторе будет иметь следующий аналог (аналогичный с предыдущим подходом):

	Имя пользователя: <strong>{user.title}</strong>
	
Переменные можно объявлять и в ini-файлах. Например, можно создать файл options.init.ini и записать в нём следующие строки:

	[user]
	login=petya
	password=12345
	
Обращаться к таким конструкциям можно как к массивам:

	print d()->user['login'];
	
Что в шаблонизаторе будет иметь следующий аналог (аналогичный с предудыщим подходом):

	Логин и пароль пользователя: <strong>{user.login} : {user.password}</strong>

Таким образом, один из подходов в шаблонизации следующий:

1.   Описывается и вызывается функция, которая подготавливает объекты и строки и помещает их в переменые.
2.   Дополнительно вызываются функции, которые дорабатывают эти переменные.
3.   Вызывается функция представления, которая выводит переменные в HTML-код.

При выводе переменных можно использовать фильтры, например:
	
	Безопасный вывод: {user.name|h} обрезка тегов при помощи htmlspechialchars.
	Вывод в верхнем регистре: {user.name|strtoupper} 

О фильтрах рассказано подробнее в соответствующем месте.

### Функции
Функции - вторая основополагающая сущность. Все функции являются методами основного объекта (исключение - методы контроллеров).
Все шаблоны, все функции контроллера, выполненные не в классах, все сниппеты, фильтры, помощники являются функциями и вызываются одинаково:
	
	print d()->function_name();

Например, в файле index.php вызывается шаблон main.html следующим образом: 
	
	print d()->main();
	
Внутри шаблона main есть конструкция `{{content}}`, которая преобразуется в следующий PHP-код:

	print d()->content();
	
Альтернативный способ записи следующий: 

	<?php print d()->call('function_name' [, $массив_с_параметрами_функции]); ?>
	
Таким образом, запись `{{function_name}}` в шаблоне выведет в этом месте результат работы функции `d()->function_name();`

Чтобы объявить такую функцию, есть два способа:

**Первый**: объявить её в любом из подключаемых файлов. Например, создать файл my_functions.func.php и записать в нём:

	function my_func()
	{
		return "Привет, мир!";
	}

После этого можно использовать функцию следующим образом:

Контроллер:

	d()->title = d()->my_func();

Шаблон:

	Приложение сообщает: <b>{title}</b>
	
Либо без контроллера:

	Приложение сообщает: <b>{{my_func}}</b>
	
Ни одна из функций не производит вывод напрямую, даже если внутри их кода есть вызовы `print` или `echo`. 
Каждая функция возвращает результат, а программист по своему желанию либо выводит его,
либо использует как параметр для другой функции или записывает в переменную.

**Второй**: создать файл с расширением .html, например, если создать файл с именем `banner.html`, со следующим содержимым:
	
	<div class="banner">Баннер!</div>	
	
то можно будет использовать следующую конструкцию:
	
	print d()->banner();
	
Или выводить её в представлении:

	<p>А дальше реклама:</p>
	{{banner}}
	<p>Реклама закончилась</p>
	
В .html файлах, как правило, хранятся шаблоны вида. В принципе, можно обойтись только ими, пренебрегая контроллером и используя внутри них 
прямые вставки php-кода, но это является плохим тоном и усложняет дальнейшую поддержку. Однако никто не запрещает пользоваться логикой представления, используя 
конструкции `if(){}`.

Так как такие функции остаются функциями, внутри них можно использовать `return`.

Например, если у нас есть файл `get_summ.html` со следующим содержимым:

	<h2>Получение суммы</h2>
	Дальше вычисляется сумма<br>
	<?php
		return d()->first + d()->second;
	?>
	Конец<br>

то следующая конструкция:
	
	d()->first=3;
	d()->second=2;
	print d()->get_summ();
	
выведет не весь шаблон, а только строку '5'. Это можно использовать, например, для прекращения вывода текущего шаблона (файл adminka.html):

	<h2>Панель администрирования</h2>
	<?php 
		if(!d()->is_admin()) {
			return " Вы являетесь неавторизованным пользователем";
		}
	?>
	<button>Кнопка удаления аккаунта</button>	
	
При попытке не авторизованного запуска фрагмента `{{adminka}}` не будет выведен заголовок в теге `<h2>` и кнопка, зато будет выведена запрещающая строка.

Также можно перенаправлять вывод другим функциям:

	if(!d()->is_admin()) {
		return d()->registration_form();
	}
	
Если описываемый файл расположен, например, в папке `mod_adv`, то скорее всего файл назван `adv_banner.html` и вызывается конструкцией `{{adv_banner}}`.
В этом случае имя файла можно начать со знака подчёркивания, опустив префикс: `_banner.html`.

Другими словами, если имя файла-шаблона начинается со знака подчёркивания, то ему приписывается префикс, исходя из имени папки, в котором он расположен.

Например, в папке `mod_clients` могут быть расположены следующие шаблоны:

	_show.html
	_edit.html
	_list.html
	_new.html
	_search.html

Вызываются они следующим образом:

	print d()->clients_show.html
	print d()->clients_edit.html
	print d()->clients_list.html
	print d()->clients_new.html
	print d()->clients_search.html
	
Или, в шаблонах:
	
	{{clients_show}}
	{{clients_edit}}
	{{clients_list}}
	{{clients_new}}
	{{clients_search}}
	
Разумеется, если объявлена функция `my_function()`, то можно вызывать её в коде напрямую, опуская префикс `d()->`:
	
	print my_function();

Но в таком случае перестаёт работать система переопределения функций на основе URL (роутинг).


TODO: описать следующее

*   d()->user_controller->func()
*   {{admin#script}}
*   {{helper "mail"}}
*   {{helper "style"=>"color:red;"}}
*   main, content
*   Принцип переопределения
*   Схема работы приложения

Фрагменты
---------

### Объявление фрагмента
Для объявления фрагмента с именем fragmentname необходимо создать файл
fragmentname.html в директории app.

Также можно объявить функцию (например, в файле filename.func.php в директории app),
которая будет возвращать вывод фрагмента.

### Поиск фрагмента

Механизм поиска нужного фрагмента для запуска довольно нетривиален.

1. При попытке запуска функции ищется сама функция с этим именем.
2. Если такая функция отсутствует, то выполняется функция, оканчивающая на _tpl.
3. Если существует файл main.html, то объявится функция main_tpl().

Таким образом, для вставки фрагмента шаблона с именем footer, необходимо создать файл
footer.html и вызвать `{{footer}}` там, где надо. Это сработает только в том случае, если функция
footer() отсутствует (правило 2). Также можно использовать `{{footer_tpl}}`. Также можно создать
файл footer.tpl.html, результат будет абсолютно тем же. Префикс .tpl всегда можно опускать.

Если необходимо использовать обычную функцию, просто объявляется функция.

Если необходимо использовать пару функция/функция-шаблон, то объявляется функция
`clients_show()`, и шаблон clients_show.html
Для вызова первой используется `clients_show()`, для второй `clients_show_tpl()`.

(не реализовано) При вызове обычной функции, если шаблон существует, то он будет
присоединён в цепочке к существующей по умолчанию.

Например, `d()->main()` при отсутствии функции `main()` выполнит `d()->main_tpl();`

Однако, если существует файл main.tpl.html, то объявится функция `main_tpl()`.

Фрагмент по сути есть метод основного объекта системы, который возвращает HTML код либо
промежуточные данные. При наличии файла fragmentname.html такая функция объявится
автоматически.

Имя фрагмента может содержать латинские буквы, цифры и знак подчёркивания (как и
названия функций).

Цепочки вызовов
---------------
Система устроена так, чтобы дать возможность переопределить любую функцию в зависимости от текущего URL. При этом можно переопределять практически всё: 
фрагменты шаблонов, помощники, фильтры, методы классов контроллеров, действия-обработчики форм, и так далее. 

Допустим, в роутере указана следующая строка

	/ content default default_tpl
	
Это означает, что на страницах, начинащихся с / (всех) при вызове функции content выполнится
`d()->default()`, а затем `d()->default_tpl()`. В первом файле может проводиться инициализация, а
во втором - вывод.
Можно вызвать безымянную цепочку напрямую: 

	d()->call('default', 'default_tpl');

Каждый
элемент из цепочки не будет переопределён по правилам переопределения.
### `set_next_chain`

	d()->set_next_chain('название_функции')

Переопределяет следующий элемент в цепочке
вызовов, определённой в роутере. Она переопределяет следующий элемент в очереди, или
добавляет новый, если такого элемента нет.

например, `d()->set_next_chain('fosv')` вызовет `d()->fosv()` сразу после окончания работы текущей
функции. Её вывод присоединится к выводу текущей функции.

### `stop_next_chains`
`d()->stop_next_chains()` отменит все следующие функции в цепочке.

Вызов врагментов
----------------
Для вызова фрагмента и получения его вывода необходимо вызвать `doit()->fragmentname();`
Соответственно, для вывода `<?php print doit()->fragmentname(); ?>`

Внутри шаблонов можно использовать `<?php print $this->fragmentname(); ?>`. Все функции
фрагментов не выводят данные, а только возвращают, это означает, что полученные данные
всегда можно дополнительно обработать.

В контексте шаблона можно использовать короткую запись `{{fragmentname}}`.

В процессе работы сайта, как правило, первым вызывается фрагмент `main()`, который вызывает
остальные (например, content для основного содержимого страницы). На комбинации
фрагментов и стоится сайт, с учётом того, что фрагменты могут быть переопределены с учётом
текущего URL (например, переопределён основной макет, середина страницы, заголовок
(header.html), функция получения списка с данными и иные функции по желанию
разработчика).

Если фрагмент или функция вернули `return "текст"`, то вывод переопределится эти текстом.

ini-файлы и их применения
-------------------------
ini - файлы применяются для следующих случаев:


*   роутеры адресов
*   предварительные и последующие вызовы функций
*   поля и их типы для редактирования
*   опции сайта в целом (адреса электронной почты)
*   логины и пароли администраторов
*   такие вещи, как текущий город или страна (для мультирегиональных сайтов)
*   названия и типы полей для редактирования в системе администрирования
*   пути к различным файлам, опции для подключения к базам данных


Стандартные функции
-------------------

### `url`
Функция url позволяет узнать, какие параметры есть в адресе текущей страницы

Пример использования:

Допустим, URL страницы /users/ainu/comments/13/14/52/page/4/edit?yes=no


	print url() // users/ainu/comments/13/14/52/page/4/edit
	print url(1) // users
	print url(2) // ainu
	print url('users') // ainu
	print url('page') // 4
	print url('comments',3) // 13/14/52
	print url('comments',-2) // 13/14/52/page

Формы, валидаторы и действия (action)
-------------------------------------
TODO:

	{{form}}
	[validator.mail.title]
	d()->action('form#send');

Два типа действий - с перезагрузкой и действием

Модуль Active Record (mod_orm)
------------------------------
mod_orm добавляет поддержку объекта Active Record для упрощения SQL-запросов.

Если функция не имеет параметров, то её можно вызывать в качестве переменной, просто
опустив скобки (в большинстве случаев также доступен классический подход), например

	d()->User->all
	d()->User->one
	d()->User->expand_to_client

### Объявление
Для указания того, какой таблице соответствует объект, ничего не нужно. Объявлять класс для
каждого отдельного типа объекта тоже не обязательно.

Для поиска по таблице users используется запись `d()->Users;`

Например:

	d()->User->find(2)->title;

Для поиска по любой другой таблице используется имя объекта, начинаемое с заглавной
буквы, и представляющее собой название таблицы в единственном числе по правилам
английской грамматики.

Например, `d()->Category` ищет по таблице categories, а `d()->News` ищет по таблице news

Альтернативная запись `d('User')` (Примечание: такая запись подходит для запроса любого
свойства основного объекта, например, `d('title')`).

Для дальнейшего использования можно передавать вызовы по цепочке или используя
промежуточный объект:

	print d()->User->find(2)->title;

равнозначно

	$user= d()->User;
	$user=$user->find(2);
	print $user->title;

либо равнозначно

	$user2= d()->User;
	$user2->find(2);
	print $user2->login;
	
Также разрешён альтернативный подход

	$user2= new User();
	$user2->find(2);
	print $user2->login;

Также разрешается объявлять класс самому, наследуя его от класса ar

В этом случае имеется возможность использовать свои методы класса и переопределять
существующие.

### `find()`

Осуществляет поиск по id

	d()->User->find(34);
	
Непосредственно запрос выполнится перед получением данных (ленивый запрос).

Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### `find_by_<field>`

Ищет по определённому полю и автоматически экранирует запрос для предотвращения SQL-
инъекций. Например:

	d()->User->find_by_login('ainu') 	// ищет по полю login
	d()->User->find_by_username('ainu') // ищет по полю username
	
Отменяет действие выполненных ранее функций `find()`, `find_by_*()`, `where()`

### `where()`

where задаёт условия для будущего запроса и автоматически экранирует запрос для
предотвращения SQL-инъекций. Отменяет действие выполненных ранее функций `find()`,
`find_by_*()`, `where()`

Например:

	d('User')->where('login = ? and password=?', $username, md5($password));
	d('User')->where('login LIKE ?', '%строка%');
	
### `all`
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов ActiveRecord).

	$goods = d()->Good->find_by_color('red')->all;
	print $goods[0]->title;

	
### `tree`
Выполняет SQL-запрос (если не выполнен) и возвращает массив всех данных (в виде массива
объектов ActiveRecord). При этом, даже если была запрошен вся таблица, в массиве будут только данные из корня.

Допустим, текущая таблица comments. Каждый комментарий имеет поле `page_id` (или, допустим, url страницы) и `comment_id`, указывающий на родительский комментарий.

Тогда получив все комментарии к одной странице, где `page_id=номер страницы`, и запросив tree, мы получим только корневые элементы - комментарии. Запросив свойство tree каждого из этих комментариев, мы получим дочерние комментарии. При этом делается один запрос, и данные сортируются и прозрачно помещаются в многомерный массив.

Используется для простой выдачи многомерных деревьев (комментарии, главные меню и так далее).

По сути, функция tree всего лишь сортирует данные в массиве, ориентируясь на поле element_id, где текущая таблица - elements, и возвращает результат. Таким образом  одним запросом получаются все данные дерева, программно сортируются, и выводятся в виде заранее подготовленного массива с данными. Глубина безлимитна.

	//Дерево комментариев
	d()->comments = d()->Comment->find_by_page_id(12)->tree;
	//Комментарий четвёртого уровня вложенности
    print  d()->Text->tree[0]->tree[0]->tree[0]->tree[0]->title; 
	
### one
Выполняет SQL-запрос (если не выполнен) и возвращает один объект (первый) в виде
объекта. Почти всегда можно опускать (при запросе свойства запрос выполнится автоматически).

	$maika = d()->Good->find(12)->one;
	
### `is_empty`
Немедленно выполняет SQL - запрос (до попытки получения первого свойства), и возвращает
true, если получено 0 элементов.

### `expand` и `expand_to`
Функции копируют данные из ActiveRecord объекта в глобальную область объектов для
использования в шаблонах

	d('Text')->find_by_url(url(1))->expand_to_page;
	
После этого в шаблоне можно указывать `{page.title}`

	d()->Client->find_by_name('Керхер')->expand_to_client;
	
После этого в шаблоне можно указывать `{client.title}`

	d()->Client->find(374)->expand;
	
После этого в шаблоне можно указывать `{title}`

Примечание: от функции expand можно отказаться классическим методом:

	d()->page = d('Text')->find_by_url(url(1));
	
После этого в шаблоне можно указывать `{page.title}`

Возвращает `false`, если подходящих строк не было найдено.

### `new`, `save` и `delete`
`save` и `delete` завершают предыдущие операции, используются для установки флага
дальнейшего создания строки в базе данных, сохранения данных и удаления строки.

`delete` - удаляет последний найденный через find элемент, если элементы искались через
where, то удаляется первый. Фактически, при `$var->delete;` удаляется элемент с id, равным `$var->id`.

Если такой строки нет, ничего не произойдёт.

`save` - сохраняет изменения. Функция new не совершает никаких действий с базой данных,
только указывает на необходимость создания новой строки в базе данных. Если до save было
сделано $var->new, то при сохранении создастся новая строка, иначе изменится последняя
найденная через find или where строка. Если при попытке сохранения для изменений после
поиска строк было несколько, то изменится первая. Фактически, при $var->save; меняется
элемент с `id` = $var->id. Если такой строки нет, ничего не произойдёт.

Для задания поля необходимо присвоить значение соответствующей переменной. Например,

	$var->title='Заголовок';
	
Внимание: регистр букв важен.
Итак, основные действия:

**Создание:**

	d()->client = d()->Client->new;
	d()->client->title='ainu';
	d()->client->text='Суперклиент';
	d()->client->save();
	
**Редактирование:**

	d()->client = d()->Client->find(12);
	d()->client->title = "Новый заголовок";
	d()->client->save();
	
**Удаление:**

	d()->client = d()->Client->find(12);
	d()->client->delete();
	
Если (например, при редактировании или создании) не было присвоено значение полю, то в
самом запросе с этим полем действий не произойдёт. На данном этапе абстракций нет,
поэтому для указания, например, автора статьи, необходимо указывать id:

	$article = d()->Article->new;
	$article->author_id = 21;
	$article->save;
	
При указании `->new` можно действовать так:

	d()->client = d()->Client;
	d()->client->new;
	d()->client->title='Имя';
	d()->client->save;
	
или так:

	d()->client = d()->Client;
	d()->client->new->title='Имя';
	d()->client->save;
	
или вообще без промежуточного объекта:

	d()->Client->find(7)->delete();
	
### Связи

Все три вида связей (one-to-many, many-to-one, many-to-many) объявляются автоматически.

TODO:

	$user->posts
	$post->user

